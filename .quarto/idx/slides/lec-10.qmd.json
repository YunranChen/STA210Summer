{"title":"Types of predictors","markdown":{"yaml":{"title":"Types of predictors","subtitle":"STA 210 - Spring 2022","author":"Dr. Mine Çetinkaya-Rundel","footer":"[sta210-s22.github.io/website](https://sta210-s22.github.io/website/)","logo":"images/logo.png","format":{"revealjs":{"theme":"slides.scss","multiplex":true,"transition":"fade","slide-number":true,"incremental":true,"chalkboard":true}},"editor":"visual","execute":{"freeze":"auto"}},"headingText":"| include: false","containsRefs":false,"markdown":"\n\n```{r}\n\n# figure options\nknitr::opts_chunk$set(\n  fig.width = 10, fig.asp = 0.618,\n  fig.retina = 3, dpi = 300, fig.align = \"center\"\n)\n```\n\n# Welcome\n\n## Announcements\n\n::: nonincremental\n-   Congratulations on finishing Exam 1!\n-   Grading of AEs\n-   Questions on feedback vs. regrades\n:::\n\n## Topics\n\n::: nonincremental\n-   Mean-centering quantitative predictors\n\n-   Using indicator variables for categorical predictors\n\n-   Using interaction terms\n:::\n\n## Computational setup\n\n```{r}\n#| echo: true\n\n# load packages\nlibrary(tidyverse)\nlibrary(tidymodels)\nlibrary(openintro)\nlibrary(patchwork)\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(colorblindr)\n\n# set default theme and larger font size for ggplot2\nggplot2::theme_set(ggplot2::theme_minimal(base_size = 20))\n```\n\n# Introduction\n\n## Data: Peer-to-peer lender\n\nToday's data is a sample of 50 loans made through a peer-to-peer lending club.\nThe data is in the `loan50` data frame in the **openintro** R package.\n\n```{r}\nloan50 %>%\n  select(annual_income, debt_to_income, verified_income, interest_rate)\n```\n\n## Variables {.smaller}\n\n**Predictors**:\n\n::: nonincremental\n-   `annual_income`: Annual income\n-   `debt_to_income`: Debt-to-income ratio, i.e. the percentage of a borrower's total debt divided by their total income\n-   `verified_income`: Whether borrower's income source and amount have been verified (`Not Verified`, `Source Verified`, `Verified`)\n:::\n\n**Outcome**: `interest_rate`: Interest rate for the loan\n\n## Outcome: `interest_rate`\n\n```{r}\nggplot(loan50, aes(x = interest_rate)) +\n  geom_density() +\n  labs(title = \"Distribution of interest rate\")\n```\n\n```{r}\nloan50 %>%\n  summarise(\n    min = min(interest_rate),\n    median = median(interest_rate),\n    max = max(interest_rate)\n  ) %>%\n  kable()\n```\n\n## Predictors\n\n```{r}\np1 <- ggplot(loan50, aes(y = verified_income)) +\n  geom_bar() +\n  labs(title = \"Verified Income\")\n\np2 <- ggplot(loan50, aes(x = debt_to_income)) +\n  geom_histogram(binwidth = 0.25) +\n  labs(title = \"Debt to income ratio\")\n\np3 <- ggplot(loan50, aes(x = annual_income)) +\n  geom_histogram(binwidth = 20000) +\n  labs(title = \"Annual income\")\n\np1 + p2 / p3\n```\n\n## Data manipulation 1: Rescale income\n\n```{r}\n#| echo: true\n\nloan50 <- loan50 %>%\n  mutate(annual_income_th = annual_income / 1000)\n\nggplot(loan50, aes(x = annual_income_th)) +\n  geom_histogram(binwidth = 20) +\n  labs(title = \"Annual income (in $1000s)\")\n```\n\n## Outcome vs. predictors\n\n```{r}\np4 <- ggplot(loan50, aes(x = verified_income, y = interest_rate)) +\n  geom_boxplot(fill = \"#5B888C\") +\n  labs(\n    y = \"Interest Rate\",\n    x = \"Income verification\"\n  )\n\np5 <- ggplot(loan50, aes(x = debt_to_income, y = interest_rate)) +\n  geom_point(color = \"#5B888C\") +\n  labs(\n    y = NULL,\n    x = \"Debt to income ratio\"\n  )\n\n\np6 <- ggplot(loan50, aes(x = annual_income_th, y = interest_rate)) +\n  geom_point(color = \"#5B888C\") +\n  labs(\n    y = NULL,\n    x = \"Annual income (in $1000s)\"\n  )\n\np4 + p5 / p6\n```\n\n## Fit regression model\n\n```{r}\n#| echo: true\nint_fit <- linear_reg() %>%\n  set_engine(\"lm\") %>%\n  fit(interest_rate ~ debt_to_income + verified_income  + annual_income_th,\n      data = loan50)\n```\n\n## Summarize model results {.smaller}\n\n```{r}\ntidy(int_fit, conf.int = TRUE) %>%\n  kable(digits = 3)\n```\n\n. . .\n\n<br>\n\n::: question\nDescribe the subset of borrowers who are expected to get an interest rate of 10.726% based on our model.\nIs this interpretation meaningful?\nWhy or why not?\n:::\n\n# Mean-centered variables\n\n## Mean-centering\n\nIf we are interested in interpreting the intercept, we can **mean-center** the quantitative predictors in the model.\n\nWe can mean-center a quantitative predictor $X_j$ using the following:\n\n$$X_{j_{Cent}} = X_{j}- \\bar{X}_{j}$$\n\n. . .\n\nIf we mean-center all quantitative variables, then the intercept is interpreted as the expected value of the response variable when all quantitative variables are at their mean value.\n\n## Data manipulation 2: Mean-center numeric predictors\n\n```{r}\n#| echo: true\nloan50 <- loan50 %>%\n  mutate(\n    debt_inc_cent = debt_to_income - mean(debt_to_income), \n    annual_income_th_cent = annual_income_th - mean(annual_income_th)\n    )\n```\n\n## Visualize mean-centered predictors\n\n```{r}\np1 <- ggplot(loan50, aes(x = debt_to_income)) +\n  geom_density(fill = \"#5B888C\", alpha = 0.7) +\n  labs(x = NULL, title = \"Debt to income ratio\")\n\np2 <- ggplot(loan50, aes(x = debt_inc_cent)) +\n  geom_density(fill = \"#9dbdbf\", alpha = 0.7) +\n  labs(x = NULL, title = \"Mean-centered\\nDebt to income ratio\")\n\np3 <- ggplot(loan50, aes(x = annual_income_th)) +\n  geom_density(fill = \"#5B888C\", alpha = 0.7) +\n  labs(x = NULL, title = \"Annual income (in $1000s)\")\n\np4 <- ggplot(loan50, aes(x = annual_income_th_cent)) +\n  geom_density(fill = \"#9dbdbf\", alpha = 0.7) +\n  labs(x = NULL, title = \"Mean-centered\\nAnnual income (in $1000s)\")\n\n(p1 + p3) / (p2 + p4)\n```\n\n## Using mean-centered variables in the model {.smaller}\n\n::: question\nHow do you expect the model to change if we use the `debt_inc_cent` and `annual_income_cent` in the model?\n:::\n\n. . .\n\n```{r}\nint_cent_fit <- linear_reg() %>%\n  set_engine(\"lm\") %>%\n  fit(interest_rate ~ debt_inc_cent + verified_income + annual_income_th_cent, \n      data = loan50)\n\ntidy(int_cent_fit, conf.int = T)\n```\n\n## Original vs. mean-centered model {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n```{r}\ntidy(int_fit) %>%\n  select(term, estimate) %>%\n  kable(digits = 3)\n```\n:::\n\n::: {.column width=\"50%\"}\n```{r}\ntidy(int_cent_fit) %>%\n  select(term, estimate) %>%\n  kable(digits = 3)\n```\n:::\n:::\n\n# Indicator variables\n\n## Indicator variables\n\n-   Suppose there is a categorical variable with $K$ categories (levels)\n\n-   We can make $K$ indicator variables - one indicator for each category\n\n-   An **indicator variable** takes values 1 or 0\n\n    -   1 if the observation belongs to that category\n    -   0 if the observation does not belong to that category\n\n## Data manipulation 3: Create indicator variables for `verified_income`\n\n```{r}\n#| echo: true\n\nloan50 <- loan50 %>%\n  mutate(\n    not_verified = if_else(verified_income == \"Not Verified\", 1, 0),\n    source_verified = if_else(verified_income == \"Source Verified\", 1, 0),\n    verified = if_else(verified_income == \"Verified\", 1, 0)\n  )\n```\n\n. . .\n\n```{r}\nloan50 %>%\n  select(verified_income, not_verified, source_verified, verified) %>%\n  slice(1, 3, 6)\n```\n\n## Indicators in the model {.smaller}\n\n-   We will use $K-1$ of the indicator variables in the model.\n-   The **baseline** is the category that doesn't have a term in the model.\n-   The coefficients of the indicator variables in the model are interpreted as the expected change in the response compared to the baseline, holding all other variables constant.\n-   This approach is also called **dummy coding**.\n\n. . .\n\n```{r}\nloan50 %>%\n  select(verified_income, source_verified, verified) %>%\n  slice(1, 3, 6)\n```\n\n## Interpreting `verified_income` {.smaller}\n\n```{r}\ntidy(int_cent_fit, conf.int  = T) %>%\n  kable(digits = 3) %>%\n  row_spec(c(3,4), background = \"#D9E3E4\")\n```\n\n. . .\n\n-   The baseline category is `Not verified`.\n-   People with source verified income are expected to take a loan with an interest rate that is 2.211% higher, on average, than the rate on loans to those whose income is not verified, holding all else constant.\n-   People with verified income are expected to take a loan with an interest rate that is 6.880% higher, on average, than the rate on loans to those whose income is not verified, holding all else constant.\n\n# Interaction terms\n\n## Interaction terms\n\n-   Sometimes the relationship between a predictor variable and the response depends on the value of another predictor variable.\n-   This is an **interaction effect**.\n-   To account for this, we can include **interaction terms** in the model.\n\n## Interest rate vs. annual income\n\nThe lines are not parallel indicating there is an **interaction effect**.\nThe slope of annual income differs based on the income verification.\n\n```{r}\np1 <- ggplot(loan50, \n             aes(x = annual_income_th, y = interest_rate)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  labs(\n    x = \"Annual income (in $1000s)\",\n    y = \"Interest rate\"\n  )\n\np2 <- ggplot(loan50, \n             aes(x = annual_income_th, y = interest_rate,\n                 color = verified_income)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  labs(x = \"Annual income (in $1000s)\", y = NULL, color = NULL) +\n  theme(legend.position = c(0.6, 0.9)) +\n  scale_color_OkabeIto()\n\np1 + p2 +\n  plot_annotation(title = \"Interest rate vs. annual income\")\n```\n\n## Interaction term in model {.smaller}\n\n```{r}\n#| echo: true\nint_cent_int_fit <- linear_reg() %>%\n  set_engine(\"lm\") %>%\n  fit(interest_rate ~ debt_inc_cent  +  debt_inc_cent + \n        annual_income_th_cent + verified_income * annual_income_th_cent,\n      data = loan50)\n```\n\n```{r}\ntidy(int_cent_int_fit) %>%\n  kable(digits = 3) %>%\n  row_spec(c(6,7), background = \"#D9E3E4\")\n```\n\n## Interpreting interaction terms\n\n-   What the interaction means: The effect of annual income on the interest rate differs by -0.016 when the income is source verified compared to when it is not verified, holding all else constant.\n-   Interpreting `annual_income` for source verified: If the income is source verified, we expect the interest rate to decrease by 0.023% (-0.007 + -0.016) for each additional thousand dollars in annual income, holding all else constant.\n\n## Data manipulation 4: Create interaction variables {.smaller}\n\nDefining the interaction variable in the model formula as `verified_income * annual_income_th_cent` is an implicit data manipulation step as well\n\n```{r}\nlibrary(hardhat)\n\nframed <- model_frame(interest_rate ~ debt_inc_cent  +  debt_inc_cent + annual_income_th_cent + verified_income * annual_income_th_cent, data = loan50)\n\nmodel_matrix(framed$terms, framed$data) %>%\n  glimpse()\n```\n\n# Wrap up\n\n## Recap\n\n-   Mean-centering quantitative predictors\n\n-   Using indicator variables for categorical predictors\n\n-   Using interaction terms\n\n## Looking backward {.smaller}\n\nData manipulation, with **dplyr** (from **tidyverse**):\n\n```{r}\n#| echo: true\n#| results: hide\n\nloan50 %>%\n  select(interest_rate, annual_income, debt_to_income, verified_income) %>%\n  mutate(\n    # 1. rescale income\n    annual_income_th = annual_income / 1000,\n    # 2. mean-center quantitative predictors\n    debt_inc_cent = debt_to_income - mean(debt_to_income),\n    annual_income_th_cent = annual_income_th - mean(annual_income_th),\n    # 3. create dummy variables for verified_income\n    source_verified = if_else(verified_income == \"Source Verified\", 1, 0),\n    verified = if_else(verified_income == \"Verified\", 1, 0),\n    # 4. create interaction variables\n    `annual_income_th_cent:verified_incomeSource Verified` = annual_income_th_cent * source_verified,\n    `annual_income_th_cent:verified_incomeVerified` = annual_income_th_cent * verified\n  )\n```\n\n## Looking forward {.smaller}\n\n**Feature engineering**, with **recipes** (from **tidymodels**):\n\n```{r}\n#| label: recipe\n#| echo: true\n\nloan_rec <- recipe( ~ ., data = loan50) %>%\n  # 1. rescale income\n  step_mutate(annual_income_th = annual_income / 1000) %>%\n  # 2. mean-center quantitative predictors\n  step_center(all_numeric_predictors()) %>%\n  # 3. create dummy variables for verified_income\n  step_dummy(verified_income) %>%\n  # 4. create interaction variables\n  step_interact(terms = ~ annual_income_th:verified_income)\n```\n\n## Recipe\n\n```{r}\n#| echo: true\n\nloan_rec\n```\n"},"formats":{"revealjs":{"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"error":false,"eval":true,"cache":null,"freeze":"auto","echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","incremental":true,"output-file":"lec-10.html"},"language":{},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"0.9.345","auto-stretch":true,"editor":"visual","title":"Types of predictors","subtitle":"STA 210 - Spring 2022","author":"Dr. Mine Çetinkaya-Rundel","footer":"[sta210-s22.github.io/website](https://sta210-s22.github.io/website/)","logo":"images/logo.png","theme":"slides.scss","multiplex":true,"transition":"fade","slideNumber":true,"chalkboard":true}}}}